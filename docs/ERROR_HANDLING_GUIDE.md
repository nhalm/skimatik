# Enhanced Error Handling Guide

This guide demonstrates how to use the powerful error handling system generated by skimatik. The system provides consistent, type-safe error handling that's easy to use and extend.

## Overview

The generated code includes:

1. **Shared Error Types**: Common error types like `ErrNotFound`, `ErrAlreadyExists`, etc.
2. **Structured Error Information**: `DatabaseError` struct with operation, entity, and detail information
3. **Type-Safe Checking Functions**: `IsNotFound()`, `IsValidationError()`, etc.
4. **Reusable Utilities**: `HandleDatabaseError()` for your custom database operations

## Basic Usage

### 1. Type-Safe Error Checking

```go
user, err := userRepo.Get(ctx, userID)
if err != nil {
    // Use type-safe error checking instead of string matching
    if IsNotFound(err) {
        return nil, fmt.Errorf("user %s does not exist", userID)
    }
    if IsConnectionError(err) {
        return nil, fmt.Errorf("database temporarily unavailable")
    }
    return nil, err
}
```

### 2. HTTP Handler Example

```go
func createUserHandler(w http.ResponseWriter, r *http.Request) {
    var params CreateUserParams
    // ... parse request ...
    
    user, err := userRepo.Create(ctx, params)
    if err != nil {
        // Clean error handling with appropriate HTTP status codes
        switch {
        case IsAlreadyExists(err):
            http.Error(w, "Email already registered", http.StatusConflict)
        case IsValidationError(err):
            http.Error(w, err.Error(), http.StatusBadRequest)
        case IsTimeout(err):
            http.Error(w, "Request timeout", http.StatusRequestTimeout)
        case IsConnectionError(err):
            http.Error(w, "Service unavailable", http.StatusServiceUnavailable)
        default:
            log.Printf("Unexpected error: %v", err)
            http.Error(w, "Internal server error", http.StatusInternalServerError)
        }
        return
    }
    
    // Success case
    json.NewEncoder(w).Encode(user)
}
```

## Advanced Usage

### 3. Custom Repository with Shared Error Handling

```go
type OrderService struct {
    userRepo    *UserRepository
    productRepo *ProductRepository
    db          *pgxkit.DB
}

func (s *OrderService) CreateOrder(ctx context.Context, userID uuid.UUID, items []OrderItem) (*Order, error) {
    // Validate user exists using generated repository
    user, err := s.userRepo.Get(ctx, userID)
    if err != nil {
        if IsNotFound(err) {
            return nil, fmt.Errorf("invalid user: %w", err)
        }
        return nil, err
    }
    
    // Custom database operation using shared error handling
    query := `INSERT INTO orders (id, user_id, total, status) VALUES ($1, $2, $3, $4) RETURNING id, created_at`
    
    var order Order
    err = s.db.QueryRow(ctx, query, uuid.New(), userID, calculateTotal(items), "pending").
        Scan(&order.ID, &order.CreatedAt)
    if err != nil {
        // Use the shared error handling function
        return nil, HandleDatabaseError("create", "Order", err)
    }
    
    return &order, nil
}
```

### 4. Business Logic with Error Handling

```go
type UserService struct {
    userRepo    *UserRepository
    profileRepo *ProfileRepository
}

func (s *UserService) CreateUserWithProfile(ctx context.Context, userData CreateUserParams, profileData CreateProfileParams) (*User, error) {
    // Create user first
    user, err := s.userRepo.Create(ctx, userData)
    if err != nil {
        if IsAlreadyExists(err) {
            return nil, fmt.Errorf("user with email %s already exists", userData.Email)
        }
        return nil, fmt.Errorf("failed to create user: %w", err)
    }
    
    // Create profile
    profileData.UserID = user.ID
    _, err = s.profileRepo.Create(ctx, profileData)
    if err != nil {
        // If profile creation fails, we might want to cleanup the user
        // Handle different error types differently
        if IsValidationError(err) {
            // Don't cleanup user for validation errors - they can fix it
            return nil, fmt.Errorf("invalid profile data: %w", err)
        }
        
        // For other errors, cleanup the created user
        if cleanupErr := s.userRepo.Delete(ctx, user.ID); cleanupErr != nil {
            log.Printf("Failed to cleanup user after profile creation failure: %v", cleanupErr)
        }
        return nil, fmt.Errorf("failed to create user profile: %w", err)
    }
    
    return user, nil
}
```

### 5. Retry Logic with Connection Error Detection

```go
func (s *UserService) GetUserWithAutoRetry(ctx context.Context, userID uuid.UUID) (*User, error) {
    user, err := s.userRepo.Get(ctx, userID)
    if err != nil {
        // Check if it's a connection error that might benefit from retry
        if IsConnectionError(err) {
            log.Printf("Connection error detected, using retry method: %v", err)
            return s.userRepo.GetWithRetry(ctx, userID)
        }
        return nil, err
    }
    return user, nil
}
```

### 6. Structured Error Information

```go
func handleDatabaseError(err error) {
    var dbErr *DatabaseError
    if errors.As(err, &dbErr) {
        // Access structured error information
        log.Printf("Database error during %s operation on %s: %s", 
            dbErr.Operation, dbErr.Entity, dbErr.Detail)
        
        // Check error type
        switch dbErr.Type {
        case ErrNotFound:
            // Handle not found
        case ErrAlreadyExists:
            // Handle duplicate
        case ErrValidationFailed:
            // Handle validation error
        }
    }
}
```

## Error Types Reference

### Built-in Error Types

- `ErrNotFound` - Record not found (SQL: no rows)
- `ErrAlreadyExists` - Unique constraint violation (SQL: 23505)
- `ErrInvalidReference` - Foreign key violation (SQL: 23503)
- `ErrValidationFailed` - Check constraint violation (SQL: 23514)
- `ErrRequiredField` - Not null constraint violation (SQL: 23502)
- `ErrTimeout` - Context deadline exceeded
- `ErrDatabaseConnection` - Connection-related errors

### Checking Functions

- `IsNotFound(err)` - Check for not found errors
- `IsAlreadyExists(err)` - Check for duplicate/unique constraint errors
- `IsValidationError(err)` - Check for validation errors (includes required field errors)
- `IsConnectionError(err)` - Check for connection-related errors
- `IsTimeout(err)` - Check for timeout errors

## Testing

### 7. Testing Error Conditions

```go
func TestUserService_CreateUser_EmailExists(t *testing.T) {
    testDB := pgxkit.RequireDB(t)
    userRepo := NewUserRepository(testDB.DB)
    
    ctx := context.Background()
    
    // Create first user
    params := CreateUserParams{
        Email: "test@example.com",
        Name:  "Test User",
    }
    _, err := userRepo.Create(ctx, params)
    require.NoError(t, err)
    
    // Try to create user with same email
    _, err = userRepo.Create(ctx, params)
    require.Error(t, err)
    
    // Test using the type-safe error checking
    assert.True(t, IsAlreadyExists(err))
    assert.False(t, IsNotFound(err))
    assert.False(t, IsValidationError(err))
}
```

## Migration from String-Based Error Handling

### Before (String Matching)
```go
// ❌ Fragile string matching
if err != nil {
    if strings.Contains(err.Error(), "no rows") {
        return ErrUserNotFound
    }
    if strings.Contains(err.Error(), "duplicate key") {
        return ErrUserExists
    }
}
```

### After (Type-Safe Checking)
```go
// ✅ Type-safe error checking
if err != nil {
    if IsNotFound(err) {
        return ErrUserNotFound
    }
    if IsAlreadyExists(err) {
        return ErrUserExists
    }
}
```

## Key Benefits

1. **Consistency**: All repositories use the same error types and handling
2. **Type Safety**: No more string matching - use proper error type checking
3. **Extensibility**: Easily use `HandleDatabaseError()` in your custom database code
4. **Rich Information**: `DatabaseError` provides operation, entity, and detail context
5. **Standard Interfaces**: Works with `errors.Is()`, `errors.As()`, and error wrapping
6. **Testing Friendly**: Easy to test specific error conditions
7. **Performance**: No regex or string parsing for error detection

## Best Practices

1. **Always use type-safe checking functions** instead of string matching
2. **Wrap errors with context** when returning from business logic
3. **Use `HandleDatabaseError()`** for your custom database operations
4. **Log structured error information** for debugging
5. **Handle connection errors** with appropriate retry strategies
6. **Provide user-friendly messages** based on error types
7. **Test error conditions** using the generated error types 