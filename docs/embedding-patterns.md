# Multi-Layer Architecture with skimatik

## Overview

skimatik generates repositories that integrate seamlessly into a clean multi-layer architecture. This guide shows how to structure a real application using generated repositories as the foundation for your data access layer.

## üèóÔ∏è Recommended Project Structure

```
project/
‚îú‚îÄ‚îÄ api/                        # HTTP handlers and routes
‚îÇ   ‚îú‚îÄ‚îÄ handlers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_handler.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ order_handler.go
‚îÇ   ‚îî‚îÄ‚îÄ middleware/
‚îú‚îÄ‚îÄ service/                    # Business logic layer
‚îÇ   ‚îú‚îÄ‚îÄ user_service.go
‚îÇ   ‚îú‚îÄ‚îÄ order_service.go
‚îÇ   ‚îî‚îÄ‚îÄ notification_service.go
‚îú‚îÄ‚îÄ repository/                 # Domain repository interfaces
‚îÇ   ‚îú‚îÄ‚îÄ user_repository.go
‚îÇ   ‚îú‚îÄ‚îÄ order_repository.go
‚îÇ   ‚îî‚îÄ‚îÄ generated/              # skimatik generated code
‚îÇ       ‚îú‚îÄ‚îÄ users_generated.go
‚îÇ       ‚îú‚îÄ‚îÄ orders_generated.go
‚îÇ       ‚îî‚îÄ‚îÄ pagination.go
‚îî‚îÄ‚îÄ main.go
```

## Layer 1: Generated Data Access (repository/generated/)

skimatik generates the foundational data access layer:

```go
// repository/generated/users_generated.go
// Code generated by skimatik. DO NOT EDIT.

package generated

type Users struct {
    ID        uuid.UUID `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Email     string    `json:"email" db:"email"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
}

type CreateUsersParams struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

type UsersRepository struct {
    db *pgxkit.DB
}

func NewUsersRepository(db *pgxkit.DB) *UsersRepository {
    return &UsersRepository{db: db}
}

func (r *UsersRepository) Create(ctx context.Context, params CreateUsersParams) (*Users, error) {
    // Generated CRUD implementation
}

func (r *UsersRepository) GetByID(ctx context.Context, id uuid.UUID) (*Users, error) {
    // Generated CRUD implementation
}

func (r *UsersRepository) List(ctx context.Context) ([]Users, error) {
    // Generated CRUD implementation
}
```

## Layer 2: Domain Repository Layer (repository/)

Define domain interfaces and implement them using generated repositories:

```go
// repository/user_repository.go
package repository

import (
    "context"
    "fmt"
    "github.com/google/uuid"
    "github.com/nhalm/pgxkit"
    "your-project/repository/generated"
)

// Domain interface - defines what your business layer needs
type UserRepository interface {
    CreateUser(ctx context.Context, name, email string) (*User, error)
    GetUserByID(ctx context.Context, id uuid.UUID) (*User, error)
    GetUserByEmail(ctx context.Context, email string) (*User, error)
    ListActiveUsers(ctx context.Context) ([]User, error)
    ActivateUser(ctx context.Context, id uuid.UUID) error
}

// Domain model - can be different from generated struct
type User struct {
    ID       uuid.UUID
    Name     string
    Email    string
    IsActive bool
}

// Implementation embeds generated repository
type userRepository struct {
    *generated.UsersRepository
    db *pgxkit.DB
}

func NewUserRepository(db *pgxkit.DB) UserRepository {
    return &userRepository{
        UsersRepository: generated.NewUsersRepository(db),
        db:              db,
    }
}

func (r *userRepository) CreateUser(ctx context.Context, name, email string) (*User, error) {
    // Use generated repository for basic create
    params := generated.CreateUsersParams{
        Name:  name,
        Email: email,
    }
    
    user, err := r.UsersRepository.Create(ctx, params)
    if err != nil {
        return nil, fmt.Errorf("failed to create user: %w", err)
    }
    
    // Convert to domain model
    return &User{
        ID:       user.ID,
        Name:     user.Name,
        Email:    user.Email,
        IsActive: true,
    }, nil
}

func (r *userRepository) GetUserByEmail(ctx context.Context, email string) (*User, error) {
    // Custom query using shared database utilities
    query := `SELECT id, name, email, is_active FROM users WHERE email = $1`
    
    row := ExecuteQueryRow(ctx, r.db, "get_by_email", "User", query, email)
    
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email, &user.IsActive)
    if err := HandleQueryRowError("get_by_email", "User", err); err != nil {
        return nil, err
    }
    
    return &user, nil
}
```

## Layer 3: Business Service Layer (service/)

Implement business logic by orchestrating repositories:

```go
// service/user_service.go
package service

import (
    "context"
    "fmt"
    "github.com/google/uuid"
    "your-project/repository"
)

type UserService interface {
    RegisterUser(ctx context.Context, name, email string) (*UserProfile, error)
    GetUserProfile(ctx context.Context, userID uuid.UUID) (*UserProfile, error)
    UpdateUserProfile(ctx context.Context, userID uuid.UUID, updates ProfileUpdates) error
}

type UserProfile struct {
    ID           uuid.UUID `json:"id"`
    Name         string    `json:"name"`
    Email        string    `json:"email"`
    OrderCount   int       `json:"order_count"`
    TotalSpent   float64   `json:"total_spent"`
    MemberSince  string    `json:"member_since"`
}

type ProfileUpdates struct {
    Name  *string `json:"name,omitempty"`
    Email *string `json:"email,omitempty"`
}

type userService struct {
    userRepo  repository.UserRepository
    orderRepo repository.OrderRepository
}

func NewUserService(userRepo repository.UserRepository, orderRepo repository.OrderRepository) UserService {
    return &userService{
        userRepo:  userRepo,
        orderRepo: orderRepo,
    }
}

func (s *userService) RegisterUser(ctx context.Context, name, email string) (*UserProfile, error) {
    // Business logic: validate email, check duplicates, etc.
    existingUser, err := s.userRepo.GetUserByEmail(ctx, email)
    if err == nil && existingUser != nil {
        return nil, fmt.Errorf("user with email %s already exists", email)
    }
    
    // Create user using repository
    user, err := s.userRepo.CreateUser(ctx, name, email)
    if err != nil {
        return nil, fmt.Errorf("failed to register user: %w", err)
    }
    
    // Return enriched profile
    return &UserProfile{
        ID:          user.ID,
        Name:        user.Name,
        Email:       user.Email,
        OrderCount:  0,
        TotalSpent:  0.0,
        MemberSince: "Just now",
    }, nil
}

func (s *userService) GetUserProfile(ctx context.Context, userID uuid.UUID) (*UserProfile, error) {
    // Orchestrate multiple repositories
    user, err := s.userRepo.GetUserByID(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("user not found: %w", err)
    }
    
    // Get order statistics
    orderStats, err := s.orderRepo.GetUserOrderStats(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get order stats: %w", err)
    }
    
    return &UserProfile{
        ID:          user.ID,
        Name:        user.Name,
        Email:       user.Email,
        OrderCount:  orderStats.Count,
        TotalSpent:  orderStats.TotalAmount,
        MemberSince: user.CreatedAt.Format("January 2006"),
    }, nil
}
```

## Layer 4: API Handler Layer (api/)

Handle HTTP requests and responses:

```go
// api/handlers/user_handler.go
package handlers

import (
    "encoding/json"
    "net/http"
    "github.com/google/uuid"
    "github.com/gorilla/mux"
    "your-project/service"
)

type UserHandler struct {
    userService service.UserService
}

func NewUserHandler(userService service.UserService) *UserHandler {
    return &UserHandler{userService: userService}
}

type CreateUserRequest struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    
    profile, err := h.userService.RegisterUser(r.Context(), req.Name, req.Email)
    if err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(profile)
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    userID, err := uuid.Parse(vars["id"])
    if err != nil {
        http.Error(w, "Invalid user ID", http.StatusBadRequest)
        return
    }
    
    profile, err := h.userService.GetUserProfile(r.Context(), userID)
    if err != nil {
        http.Error(w, err.Error(), http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(profile)
}
```

## Dependency Injection & Wiring

```go
// main.go
package main

import (
    "log"
    "net/http"
    "github.com/gorilla/mux"
    "github.com/nhalm/pgxkit"
    "your-project/api/handlers"
    "your-project/repository"
    "your-project/service"
)

func main() {
    // Initialize database
    db, err := pgxkit.NewDB("postgres://...")
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // Initialize repositories
    userRepo := repository.NewUserRepository(db)
    orderRepo := repository.NewOrderRepository(db)
    
    // Initialize services
    userService := service.NewUserService(userRepo, orderRepo)
    
    // Initialize handlers
    userHandler := handlers.NewUserHandler(userService)
    
    // Setup routes
    r := mux.NewRouter()
    r.HandleFunc("/users", userHandler.CreateUser).Methods("POST")
    r.HandleFunc("/users/{id}", userHandler.GetUser).Methods("GET")
    
    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

## Key Benefits

### Clear Separation of Concerns
- **Generated layer**: Pure data access, no business logic
- **Repository layer**: Domain-specific data operations
- **Service layer**: Business workflows and orchestration
- **API layer**: HTTP concerns and request/response handling

### Testability
```go
// Easy to mock at service boundaries
func TestUserService_RegisterUser(t *testing.T) {
    mockUserRepo := &mockUserRepository{}
    mockOrderRepo := &mockOrderRepository{}
    userService := service.NewUserService(mockUserRepo, mockOrderRepo)
    
    // Test business logic without database
}
```

### Maintainability
- **skimatik regeneration** doesn't break your code
- **Business logic** stays in service layer
- **API changes** don't affect business logic
- **Database changes** only affect generated layer

This architecture leverages skimatik's generated repositories as a solid foundation while maintaining clean separation of concerns across your entire application stack. 
- **[Examples & Tutorials](Examples-and-Tutorials)** - Hands-on examples with real applications 