package generator

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

// CodeGenerator handles generating Go code from database schema
type CodeGenerator struct {
	config      *Config
	typeMapper  *TypeMapper
	templateMgr *TemplateManager
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(config *Config) *CodeGenerator {
	return &CodeGenerator{
		config:      config,
		typeMapper:  NewTypeMapper(config.TypeMappings),
		templateMgr: NewTemplateManager(templateFS),
	}
}

// GenerateTableRepository generates a complete repository file for a table
func (cg *CodeGenerator) GenerateTableRepository(table Table) error {
	// Map column types
	if err := cg.typeMapper.MapTableColumns(&table); err != nil {
		return fmt.Errorf("failed to map column types: %w", err)
	}

	// Generate the code
	code, err := cg.generateTableCode(table)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	// Write to file
	filename := cg.config.GetOutputPath(table.GoFileName())
	if err := cg.writeCodeToFile(filename, code); err != nil {
		return fmt.Errorf("failed to write code to file: %w", err)
	}

	return nil
}

// generateTableCode generates the complete Go code for a table
func (cg *CodeGenerator) generateTableCode(table Table) (string, error) {
	// Get required imports from column types
	typeImports := cg.typeMapper.GetRequiredImports(table.Columns)

	// Add minimal imports required for table-specific operations
	coreImports := []string{
		"context",
		"fmt",
		"github.com/nhalm/pgxkit",
		"github.com/google/uuid",
	}

	// Combine and deduplicate imports
	allImports := cg.combineImports(coreImports, typeImports)

	// Generate struct
	structCode, err := cg.generateStruct(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate struct: %w", err)
	}

	// Generate repository
	repositoryCode, err := cg.generateRepository(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate repository: %w", err)
	}

	// Generate CRUD operations
	crudCode, err := cg.generateCRUDOperations(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate CRUD operations: %w", err)
	}

	// Generate enhanced features
	enhancedCode, err := cg.generateEnhancedFeatures(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate enhanced features: %w", err)
	}

	// Combine everything
	var code strings.Builder

	// Header
	code.WriteString("// Code generated by skimatik. DO NOT EDIT.\n")
	code.WriteString(fmt.Sprintf("// Source: table %s\n\n", table.Name))

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Imports - include the predicted imports so imports.Process has them to work with
	if len(allImports) > 0 {
		code.WriteString("import (\n")
		for _, imp := range allImports {
			code.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		code.WriteString(")\n\n")
	}

	// Struct definition
	code.WriteString(structCode)
	code.WriteString("\n\n")

	// Repository definition
	code.WriteString(repositoryCode)
	code.WriteString("\n\n")

	// CRUD operations
	code.WriteString(crudCode)

	// Enhanced features
	if enhancedCode != "" {
		code.WriteString("\n\n")
		code.WriteString(enhancedCode)
	}

	return code.String(), nil
}

// combineImports combines and deduplicates import lists
func (cg *CodeGenerator) combineImports(lists ...[]string) []string {
	seen := make(map[string]bool)
	var result []string

	for _, list := range lists {
		for _, imp := range list {
			if !seen[imp] {
				seen[imp] = true
				result = append(result, imp)
			}
		}
	}

	return result
}

// getQueryImports returns the imports needed for all queries
func (cg *CodeGenerator) getQueryImports(queries []Query) []string {
	imports := make(map[string]bool)

	for _, query := range queries {
		// Get imports for result columns
		queryImports := cg.typeMapper.GetRequiredImports(query.Columns)
		for _, imp := range queryImports {
			imports[imp] = true
		}

		// Get imports for parameters
		paramImports := cg.typeMapper.GetRequiredImports(convertParametersToColumns(query.Parameters))
		for _, imp := range paramImports {
			imports[imp] = true
		}
	}

	// Convert map to slice
	var result []string
	for imp := range imports {
		result = append(result, imp)
	}

	return result
}

// convertParametersToColumns converts parameters to columns for import calculation
func convertParametersToColumns(params []Parameter) []Column {
	var columns []Column
	for _, param := range params {
		columns = append(columns, Column{
			Name:   param.Name,
			Type:   param.Type,
			GoType: param.GoType,
		})
	}
	return columns
}

// generateEnhancedFeatures generates enhanced pgxkit features (retry methods)
func (cg *CodeGenerator) generateEnhancedFeatures(table Table) (string, error) {
	var code strings.Builder

	// Prepare template data
	data, err := cg.prepareCRUDTemplateData(table)
	if err != nil {
		return "", fmt.Errorf("failed to prepare template data: %w", err)
	}

	// Generate retry methods
	retryCode, err := cg.templateMgr.ExecuteTemplate(TemplateRepositoryRetry, data)
	if err != nil {
		return "", fmt.Errorf("failed to generate retry methods: %w", err)
	}
	code.WriteString(retryCode)

	// Health check methods are not generated - left to implementor

	return code.String(), nil
}

// generateStruct generates the Go struct for a table
func (cg *CodeGenerator) generateStruct(table Table) (string, error) {
	// Prepare template data
	data := struct {
		StructName   string
		TableName    string
		ReceiverName string
		IDField      string
		Fields       []struct {
			Name string
			Type string
			Tag  string
		}
	}{
		StructName:   table.GoStructName(),
		TableName:    table.Name,
		ReceiverName: strings.ToLower(table.GoStructName()[:1]),
		IDField:      table.GetPrimaryKeyColumn().GoFieldName(),
	}

	// Add fields
	for _, col := range table.Columns {
		field := struct {
			Name string
			Type string
			Tag  string
		}{
			Name: col.GoFieldName(),
			Type: col.GoType,
			Tag:  col.GoStructTag(),
		}
		data.Fields = append(data.Fields, field)
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateStruct, data)
}

// generateRepository generates the repository struct and constructor
func (cg *CodeGenerator) generateRepository(table Table) (string, error) {
	// Prepare template data
	data := struct {
		RepositoryName string
		TableName      string
	}{
		RepositoryName: table.GoStructName() + "Repository",
		TableName:      table.Name,
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateRepositoryStruct, data)
}

// generateCRUDOperations generates specified CRUD operations for a table
func (cg *CodeGenerator) generateCRUDOperations(table Table) (string, error) {
	var code strings.Builder

	// Generate template data
	data, err := cg.prepareCRUDTemplateData(table)
	if err != nil {
		return "", fmt.Errorf("failed to prepare template data: %w", err)
	}

	// Get the functions to generate for this table
	functions := cg.config.GetTableFunctions(table.Name)

	// Map function names to templates (using template manager)
	operationTemplates := map[string]string{
		"get":      TemplateGetByID,
		"create":   TemplateCreate,
		"update":   TemplateUpdate,
		"delete":   TemplateDelete,
		"list":     TemplateList,
		"paginate": TemplatePaginationSharedListPaginated,
	}

	// Generate each requested CRUD operation
	first := true
	for _, function := range functions {
		templateStr, exists := operationTemplates[function]
		if !exists {
			return "", fmt.Errorf("unknown function type: %s", function)
		}

		if !first {
			code.WriteString("\n\n")
		}
		first = false

		var result string
		var err error

		// Check if this is a template manager template (starts with "templates/")
		if strings.HasPrefix(templateStr, "templates/") {
			// Use template manager
			result, err = cg.templateMgr.ExecuteTemplate(templateStr, data)
			if err != nil {
				return "", fmt.Errorf("failed to execute template for %s: %w", function, err)
			}
		} else {
			// Use old inline template parsing
			tmpl, parseErr := template.New("crud").Parse(templateStr)
			if parseErr != nil {
				return "", fmt.Errorf("failed to parse template for %s: %w", function, parseErr)
			}

			var resultBuilder strings.Builder
			if err := tmpl.Execute(&resultBuilder, data); err != nil {
				return "", fmt.Errorf("failed to execute template for %s: %w", function, err)
			}
			result = resultBuilder.String()
		}

		code.WriteString(result)
	}

	return code.String(), nil
}

// prepareCRUDTemplateData prepares the data structure for CRUD templates
func (cg *CodeGenerator) prepareCRUDTemplateData(table Table) (map[string]interface{}, error) {
	structName := table.GoStructName()
	repositoryName := structName + "Repository"
	receiverName := strings.ToLower(structName[:1])
	idColumn := table.GetPrimaryKeyColumn()
	createParamIndex := 1
	updateParamIndex := 1

	// Build column lists
	var selectColumns []string
	var scanArgs []string
	var createFields []map[string]string
	var updateFields []map[string]string
	var insertColumns []string
	var insertPlaceholders []string
	var insertArgs []string
	var updateAssignments []string
	var updateArgs []string

	for _, col := range table.Columns {
		// Select columns and scan args (for all operations)
		selectColumns = append(selectColumns, col.Name)
		scanArgs = append(scanArgs, "&"+receiverName+"."+col.GoFieldName())

		// Skip ID column for create/update params (it's auto-generated)
		if col.Name == idColumn.Name {
			continue
		}

		// Create fields (exclude ID and columns with defaults)
		if col.DefaultValue == "" {
			createFields = append(createFields, map[string]string{
				"Name": col.GoFieldName(),
				"Type": col.GoType,
				"Tag":  col.GoStructTag(),
			})

			insertColumns = append(insertColumns, col.Name)
			insertPlaceholders = append(insertPlaceholders, fmt.Sprintf("$%d", createParamIndex))
			insertArgs = append(insertArgs, "params."+col.GoFieldName())
			createParamIndex++
		}

		// Update fields (all non-ID columns)
		updateFields = append(updateFields, map[string]string{
			"Name": col.GoFieldName(),
			"Type": col.GoType,
			"Tag":  col.GoStructTag(),
		})

		updateAssignments = append(updateAssignments, fmt.Sprintf("%s = $%d", col.Name, updateParamIndex))
		updateArgs = append(updateArgs, "params."+col.GoFieldName())
		updateParamIndex++
	}

	// ID parameter comes last in update
	updateArgs = append(updateArgs, "id")
	idParamIndex := updateParamIndex

	return map[string]interface{}{
		"StructName":         structName,
		"RepositoryName":     repositoryName,
		"ReceiverName":       receiverName,
		"TableName":          table.Name,
		"IDColumn":           idColumn.Name,
		"IDParamIndex":       idParamIndex,
		"SelectColumns":      strings.Join(selectColumns, ", "),
		"ScanArgs":           strings.Join(scanArgs, ", "),
		"CreateFields":       createFields,
		"UpdateFields":       updateFields,
		"InsertColumns":      strings.Join(insertColumns, ", "),
		"InsertPlaceholders": strings.Join(insertPlaceholders, ", "),
		"InsertArgs":         strings.Join(insertArgs, ", "),
		"UpdateAssignments":  strings.Join(updateAssignments, ", "),
		"UpdateArgs":         strings.Join(updateArgs, ", "),
	}, nil
}

// GenerateSharedPaginationTypes generates the shared pagination types file
func (cg *CodeGenerator) GenerateSharedPaginationTypes() error {
	// Prepare template data
	data := struct {
		PackageName string
	}{
		PackageName: cg.config.PackageName,
	}

	// Execute template using template manager
	result, err := cg.templateMgr.ExecuteTemplate(TemplatePaginationSharedTypes, data)
	if err != nil {
		return fmt.Errorf("failed to execute pagination template: %w", err)
	}

	// Write to file
	filename := cg.config.GetOutputPath("pagination.go")
	if err := cg.writeCodeToFile(filename, result); err != nil {
		return fmt.Errorf("failed to write pagination file: %w", err)
	}

	return nil
}

// GenerateSharedErrors generates the shared error handling utilities file
func (cg *CodeGenerator) GenerateSharedErrors() error {
	// Create the complete file content with package declaration and imports
	var code strings.Builder

	// Header
	code.WriteString("// Code generated by skimatik. DO NOT EDIT.\n")
	code.WriteString("// This file provides shared error handling utilities for all repositories\n\n")

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Execute template using template manager
	result, err := cg.templateMgr.ExecuteTemplate(TemplateSharedErrors, nil)
	if err != nil {
		return fmt.Errorf("failed to execute shared errors template: %w", err)
	}

	// Add the template content
	code.WriteString(result)

	// Write to file
	filename := cg.config.GetOutputPath("errors.go")
	if err := cg.writeCodeToFile(filename, code.String()); err != nil {
		return fmt.Errorf("failed to write errors file: %w", err)
	}

	return nil
}

func (cg *CodeGenerator) GenerateSharedDatabaseOperations() error {
	// Create the complete file content with package declaration and imports
	var code strings.Builder

	// Header
	code.WriteString("// Code generated by skimatik. DO NOT EDIT.\n")
	code.WriteString("// This file provides shared database operation utilities for all repositories\n\n")

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Execute template using template manager
	result, err := cg.templateMgr.ExecuteTemplate(TemplateDatabaseOperations, nil)
	if err != nil {
		return fmt.Errorf("failed to execute database operations template: %w", err)
	}

	// Add the template content
	code.WriteString(result)

	// Write to file
	filename := cg.config.GetOutputPath("database_operations.go")
	if err := cg.writeCodeToFile(filename, code.String()); err != nil {
		return fmt.Errorf("failed to write database operations file: %w", err)
	}

	return nil
}

func (cg *CodeGenerator) GenerateSharedRetryOperations() error {
	// Create the complete file content with package declaration and imports
	var code strings.Builder

	// Header
	code.WriteString("// Code generated by skimatik. DO NOT EDIT.\n")
	code.WriteString("// This file provides shared retry operation utilities for all repositories\n\n")

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Execute template using template manager
	result, err := cg.templateMgr.ExecuteTemplate(TemplateRetryOperations, nil)
	if err != nil {
		return fmt.Errorf("failed to execute retry operations template: %w", err)
	}

	// Add the template content
	code.WriteString(result)

	// Write to file
	filename := cg.config.GetOutputPath("retry_operations.go")
	if err := cg.writeCodeToFile(filename, code.String()); err != nil {
		return fmt.Errorf("failed to write retry operations file: %w", err)
	}

	return nil
}

// writeCodeToFile writes generated code to a file with proper formatting
func (cg *CodeGenerator) writeCodeToFile(filename, code string) error {
	// Format the code
	formatted, err := imports.Process("", []byte(code), nil)
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	// Write to file
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filename, err)
	}

	if cg.config.Verbose {
		fmt.Printf("Generated: %s\n", filename)
	}

	return nil
}

func (cg *CodeGenerator) GenerateQueries(queries []Query) error {
	if len(queries) == 0 {
		return nil
	}

	// Group queries by source file
	queryGroups := cg.groupQueriesByFile(queries)

	// Generate code for each file group
	for sourceFile, fileQueries := range queryGroups {
		if err := cg.generateQueryFile(sourceFile, fileQueries); err != nil {
			return fmt.Errorf("failed to generate queries for file %s: %w", sourceFile, err)
		}
	}

	return nil
}

// groupQueriesByFile groups queries by their source file
func (cg *CodeGenerator) groupQueriesByFile(queries []Query) map[string][]Query {
	groups := make(map[string][]Query)
	for _, query := range queries {
		groups[query.SourceFile] = append(groups[query.SourceFile], query)
	}
	return groups
}

// generateQueryFile generates a complete Go file for a group of queries from the same source file
func (cg *CodeGenerator) generateQueryFile(sourceFile string, queries []Query) error {
	if len(queries) == 0 {
		return nil
	}

	// Map column types for all queries
	for i := range queries {
		if err := cg.typeMapper.MapQueryColumns(&queries[i]); err != nil {
			return fmt.Errorf("failed to map column types for query %s: %w", queries[i].Name, err)
		}
	}

	// Generate the code
	code, err := cg.generateQueryCode(sourceFile, queries)
	if err != nil {
		return fmt.Errorf("failed to generate query code: %w", err)
	}

	// Get output filename from first query (they all have the same source file)
	filename := cg.config.GetOutputPath(queries[0].GoFileName())

	// Write to file
	if err := cg.writeCodeToFile(filename, code); err != nil {
		return fmt.Errorf("failed to write query code to file: %w", err)
	}

	return nil
}

// generateQueryCode generates the complete Go code for a group of queries from the same source file
func (cg *CodeGenerator) generateQueryCode(sourceFile string, queries []Query) (string, error) {
	// Get required imports from all queries
	allImports := cg.getQueryImports(queries)

	// Add standard imports
	standardImports := []string{
		"context",
		"github.com/nhalm/pgxkit",
		"github.com/google/uuid",
	}

	// Check if any queries are paginated and add pagination imports
	hasPaginatedQueries := false
	for _, query := range queries {
		if query.Type == QueryTypePaginated {
			hasPaginatedQueries = true
			break
		}
	}

	if hasPaginatedQueries {
		standardImports = append(standardImports, "fmt", "encoding/base64")
	}

	// Combine and deduplicate imports
	allImports = cg.combineImports(standardImports, allImports)

	var code strings.Builder

	// Header
	code.WriteString("// Code generated by skimatik. DO NOT EDIT.\n")
	code.WriteString(fmt.Sprintf("// Source: %s\n\n", sourceFile))

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Imports - include the predicted imports so imports.Process has them to work with
	if len(allImports) > 0 {
		code.WriteString("import (\n")
		for _, imp := range allImports {
			code.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		code.WriteString(")\n\n")
	}

	// Generate result structs for queries that need them
	structsGenerated := make(map[string]bool)
	for _, query := range queries {
		if cg.needsResultStruct(query) {
			structName := cg.getQueryResultStructName(query)
			if !structsGenerated[structName] {
				structCode, err := cg.generateQueryResultStruct(query)
				if err != nil {
					return "", fmt.Errorf("failed to generate result struct for query %s: %w", query.Name, err)
				}
				code.WriteString(structCode)
				code.WriteString("\n\n")
				structsGenerated[structName] = true
			}
		}
	}

	// Generate pagination types and utilities if needed
	if hasPaginatedQueries {
		paginationCode, err := cg.generateInlinePaginationTypes()
		if err != nil {
			return "", fmt.Errorf("failed to generate pagination types: %w", err)
		}
		code.WriteString(paginationCode)
		code.WriteString("\n\n")
	}

	// Generate repository struct and constructor
	repoCode, err := cg.generateQueryRepository(sourceFile, queries)
	if err != nil {
		return "", fmt.Errorf("failed to generate query repository: %w", err)
	}
	code.WriteString(repoCode)
	code.WriteString("\n\n")

	// Generate functions for each query
	for i, query := range queries {
		if i > 0 {
			code.WriteString("\n\n")
		}

		functionCode, err := cg.generateQueryFunction(query)
		if err != nil {
			return "", fmt.Errorf("failed to generate function for query %s: %w", query.Name, err)
		}
		code.WriteString(functionCode)
	}

	return code.String(), nil
}

// generateInlinePaginationTypes generates pagination types and utilities inline for query files
func (cg *CodeGenerator) generateInlinePaginationTypes() (string, error) {
	tmpl := `// PaginationParams holds parameters for cursor-based pagination
type PaginationParams struct {
	// Cursor is the base64-encoded UUID to start pagination from
	// If empty, starts from the beginning
	Cursor string ` + "`json:\"cursor,omitempty\"`" + `

	// Limit is the maximum number of items to return
	// Must be between 1 and 100, defaults to 20
	Limit int32 ` + "`json:\"limit,omitempty\"`" + `
}

// PaginationResult holds the result of a paginated query
type PaginationResult[T any] struct {
	// Items is the list of items returned
	Items []T ` + "`json:\"items\"`" + `

	// HasMore indicates if there are more items available
	HasMore bool ` + "`json:\"has_more\"`" + `

	// NextCursor is the cursor for the next page
	// Only set if HasMore is true
	NextCursor string ` + "`json:\"next_cursor,omitempty\"`" + `
}

// encodeCursor encodes a UUID as a base64 cursor
func encodeCursor(id uuid.UUID) string {
	return base64.URLEncoding.EncodeToString(id[:])
}

// decodeCursor decodes a base64 cursor to a UUID
func decodeCursor(cursor string) (uuid.UUID, error) {
	if cursor == "" {
		return uuid.UUID{}, nil
	}

	data, err := base64.URLEncoding.DecodeString(cursor)
	if err != nil {
		return uuid.UUID{}, fmt.Errorf("invalid cursor format: %w", err)
	}

	if len(data) != 16 {
		return uuid.UUID{}, fmt.Errorf("invalid cursor length: expected 16 bytes, got %d", len(data))
	}

	var id uuid.UUID
	copy(id[:], data)
	return id, nil
}

// validatePaginationParams validates pagination parameters
func validatePaginationParams(params PaginationParams) error {
	if params.Limit <= 0 {
		return fmt.Errorf("limit must be positive, got %d", params.Limit)
	}
	if params.Limit > 100 {
		return fmt.Errorf("limit too large: maximum 100, got %d", params.Limit)
	}
	return nil
}`

	return tmpl, nil
}

// Query generation helper methods moved from query_templates.go

// needsResultStruct determines if a query needs a custom result struct
func (cg *CodeGenerator) needsResultStruct(query Query) bool {
	// Only SELECT queries (:one, :many, :paginated) need result structs
	return query.Type == QueryTypeOne || query.Type == QueryTypeMany || query.Type == QueryTypePaginated
}

// getQueryResultStructName returns the struct name for a query's result
func (cg *CodeGenerator) getQueryResultStructName(query Query) string {
	return query.GoFunctionName() + "Result"
}

// generateQueryResultStruct generates a result struct for a query
func (cg *CodeGenerator) generateQueryResultStruct(query Query) (string, error) {
	if len(query.Columns) == 0 {
		return "", fmt.Errorf("query %s has no columns for result struct", query.Name)
	}

	// Prepare template data
	data := struct {
		StructName      string
		QueryName       string
		IDField         string
		IDFieldIsPgtype bool
		Fields          []struct {
			Name string
			Type string
			Tag  string
		}
	}{
		StructName: cg.getQueryResultStructName(query),
		QueryName:  query.Name,
	}

	// Add fields from query columns and find ID field
	for _, col := range query.Columns {
		field := struct {
			Name string
			Type string
			Tag  string
		}{
			Name: col.GoFieldName(),
			Type: col.GoType,
			Tag:  col.GoStructTag(),
		}
		data.Fields = append(data.Fields, field)

		// Use the first UUID field as the ID field for pagination
		if data.IDField == "" && col.IsUUID() {
			data.IDField = col.GoFieldName()
			data.IDFieldIsPgtype = col.GoType == "pgtype.UUID"
		}
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateQueryResultStruct, data)
}

// generateQueryRepository generates the repository struct and constructor for queries
func (cg *CodeGenerator) generateQueryRepository(sourceFile string, _ []Query) (string, error) {
	// Extract base name from source file path for repository name
	parts := strings.Split(sourceFile, "/")
	filename := parts[len(parts)-1]
	baseName := strings.TrimSuffix(filename, ".sql")
	repositoryName := toPascalCase(baseName) + "Queries"

	// Prepare template data
	data := struct {
		RepositoryName string
		SourceFile     string
	}{
		RepositoryName: repositoryName,
		SourceFile:     sourceFile,
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateQueryRepository, data)
}

// generateQueryFunction generates a Go function for a specific query
func (cg *CodeGenerator) generateQueryFunction(query Query) (string, error) {
	switch query.Type {
	case QueryTypeOne:
		return cg.generateOneQueryFunction(query)
	case QueryTypeMany:
		return cg.generateManyQueryFunction(query)
	case QueryTypeExec:
		return cg.generateExecQueryFunction(query)
	case QueryTypePaginated:
		return cg.generatePaginatedQueryFunction(query)
	default:
		return "", fmt.Errorf("unsupported query type: %s", query.Type)
	}
}

// generateOneQueryFunction generates a function that returns a single row
func (cg *CodeGenerator) generateOneQueryFunction(query Query) (string, error) {
	data, err := cg.prepareQueryTemplateData(query)
	if err != nil {
		return "", err
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateQueryOne, data)
}

// generateManyQueryFunction generates a function that returns multiple rows
func (cg *CodeGenerator) generateManyQueryFunction(query Query) (string, error) {
	data, err := cg.prepareQueryTemplateData(query)
	if err != nil {
		return "", err
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateQueryMany, data)
}

// generateExecQueryFunction generates a function that executes without returning rows
func (cg *CodeGenerator) generateExecQueryFunction(query Query) (string, error) {
	data, err := cg.prepareQueryTemplateData(query)
	if err != nil {
		return "", err
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateQueryExec, data)
}

// generatePaginatedQueryFunction generates a function that returns paginated results
func (cg *CodeGenerator) generatePaginatedQueryFunction(query Query) (string, error) {
	data, err := cg.prepareQueryTemplateData(query)
	if err != nil {
		return "", err
	}

	// Execute template using template manager
	return cg.templateMgr.ExecuteTemplate(TemplateQueryPaginated, data)
}

// prepareQueryTemplateData prepares common template data for query functions
func (cg *CodeGenerator) prepareQueryTemplateData(query Query) (map[string]interface{}, error) {
	// Extract base name from source file for repository name
	parts := strings.Split(query.SourceFile, "/")
	filename := parts[len(parts)-1]
	baseName := strings.TrimSuffix(filename, ".sql")
	repositoryName := toPascalCase(baseName) + "Queries"

	// Build parameter declarations and arguments
	var paramDeclarations []string
	var paramArgs []string

	for _, param := range query.Parameters {
		paramDeclarations = append(paramDeclarations, fmt.Sprintf("%s %s", param.Name, param.GoType))
		paramArgs = append(paramArgs, param.Name)
	}

	// Build scan arguments for result columns
	var scanArgs []string
	for _, col := range query.Columns {
		scanArgs = append(scanArgs, "&result."+col.GoFieldName())
	}

	// Determine result type
	resultType := cg.getQueryResultStructName(query)
	if query.Type == QueryTypeExec {
		resultType = "" // Exec queries don't return data
	}

	// Format parameter declarations and arguments
	paramDeclStr := ""
	if len(paramDeclarations) > 0 {
		paramDeclStr = ", " + strings.Join(paramDeclarations, ", ")
	}

	paramArgStr := ""
	if len(paramArgs) > 0 {
		paramArgStr = ", " + strings.Join(paramArgs, ", ")
	}

	return map[string]interface{}{
		"FunctionName":          query.GoFunctionName(),
		"QueryName":             query.Name,
		"RepositoryName":        repositoryName,
		"SQL":                   query.SQL,
		"ResultType":            resultType,
		"ParameterDeclarations": paramDeclStr,
		"ParameterArgs":         paramArgStr,
		"ScanArgs":              strings.Join(scanArgs, ", "),
	}, nil
}
