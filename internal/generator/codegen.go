package generator

import (
	"fmt"
	"go/format"
	"os"
	"strings"
	"text/template"
)

// CodeGenerator handles generating Go code from database schema
type CodeGenerator struct {
	config      *Config
	typeMapper  *TypeMapper
	templateMgr *TemplateManager
}

// NewCodeGenerator creates a new code generator
func NewCodeGenerator(config *Config) *CodeGenerator {
	return &CodeGenerator{
		config:      config,
		typeMapper:  NewTypeMapper(config.TypeMappings),
		templateMgr: NewTemplateManager(templateFS),
	}
}

// GenerateTableRepository generates a complete repository file for a table
func (cg *CodeGenerator) GenerateTableRepository(table Table) error {
	// Map column types
	if err := cg.typeMapper.MapTableColumns(&table); err != nil {
		return fmt.Errorf("failed to map column types: %w", err)
	}

	// Generate the code
	code, err := cg.generateTableCode(table)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	// Write to file
	filename := cg.config.GetOutputPath(table.GoFileName())
	if err := cg.writeCodeToFile(filename, code); err != nil {
		return fmt.Errorf("failed to write code to file: %w", err)
	}

	return nil
}

// generateTableCode generates the complete Go code for a table
func (cg *CodeGenerator) generateTableCode(table Table) (string, error) {
	// Get required imports
	imports := cg.typeMapper.GetRequiredImports(table.Columns)

	// Add standard imports (no inline pagination imports)
	standardImports := []string{
		"context",
		"fmt",
		"github.com/jackc/pgx/v5/pgxpool",
		"github.com/google/uuid",
	}

	// Combine and deduplicate imports
	allImports := cg.combineImports(standardImports, imports)

	// Generate struct
	structCode, err := cg.generateStruct(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate struct: %w", err)
	}

	// Generate repository
	repositoryCode, err := cg.generateRepository(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate repository: %w", err)
	}

	// Generate CRUD operations
	crudCode, err := cg.generateCRUDOperations(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate CRUD operations: %w", err)
	}

	// Combine everything
	var code strings.Builder

	// Header
	code.WriteString("// Code generated by dbutil-gen. DO NOT EDIT.\n")
	code.WriteString(fmt.Sprintf("// Source: table %s\n\n", table.Name))

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Imports
	if len(allImports) > 0 {
		code.WriteString("import (\n")
		for _, imp := range allImports {
			code.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		code.WriteString(")\n\n")
	}

	// Struct definition
	code.WriteString(structCode)
	code.WriteString("\n\n")

	// Repository definition
	code.WriteString(repositoryCode)
	code.WriteString("\n\n")

	// CRUD operations
	code.WriteString(crudCode)

	return code.String(), nil
}

// generateStruct generates the Go struct for a table
func (cg *CodeGenerator) generateStruct(table Table) (string, error) {
	tmpl := `// {{.StructName}} represents a row from the {{.TableName}} table
type {{.StructName}} struct {
{{range .Fields}}	{{.Name}} {{.Type}} ` + "`{{.Tag}}`" + `
{{end}}}

// GetID returns the ID of the {{.StructName}} for pagination
func ({{.ReceiverName}} {{.StructName}}) GetID() uuid.UUID {
	return {{.ReceiverName}}.{{.IDField}}
}`

	// Prepare template data
	data := struct {
		StructName   string
		TableName    string
		ReceiverName string
		IDField      string
		Fields       []struct {
			Name string
			Type string
			Tag  string
		}
	}{
		StructName:   table.GoStructName(),
		TableName:    table.Name,
		ReceiverName: strings.ToLower(table.GoStructName()[:1]),
		IDField:      table.GetPrimaryKeyColumn().GoFieldName(),
	}

	// Add fields
	for _, col := range table.Columns {
		field := struct {
			Name string
			Type string
			Tag  string
		}{
			Name: col.GoFieldName(),
			Type: col.GoType,
			Tag:  col.GoStructTag(),
		}
		data.Fields = append(data.Fields, field)
	}

	// Execute template
	t, err := template.New("struct").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	if err := t.Execute(&result, data); err != nil {
		return "", err
	}

	return result.String(), nil
}

// generateRepository generates the repository struct and constructor
func (cg *CodeGenerator) generateRepository(table Table) (string, error) {
	tmpl := `// {{.RepositoryName}} provides database operations for {{.TableName}}
type {{.RepositoryName}} struct {
	conn *pgxpool.Pool
}

// New{{.RepositoryName}} creates a new {{.RepositoryName}}
func New{{.RepositoryName}}(conn *pgxpool.Pool) *{{.RepositoryName}} {
	return &{{.RepositoryName}}{
		conn: conn,
	}
}`

	// Prepare template data
	data := struct {
		RepositoryName string
		TableName      string
	}{
		RepositoryName: table.GoStructName() + "Repository",
		TableName:      table.Name,
	}

	// Execute template
	t, err := template.New("repository").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var result strings.Builder
	if err := t.Execute(&result, data); err != nil {
		return "", err
	}

	return result.String(), nil
}

// generateCRUDOperations generates specified CRUD operations for a table
func (cg *CodeGenerator) generateCRUDOperations(table Table) (string, error) {
	var code strings.Builder

	// Generate template data
	data, err := cg.prepareCRUDTemplateData(table)
	if err != nil {
		return "", fmt.Errorf("failed to prepare template data: %w", err)
	}

	// Get the functions to generate for this table
	functions := cg.config.GetTableFunctions(table.Name)

	// Map function names to templates (mixed approach during migration)
	operationTemplates := map[string]string{
		"get":      getByIDTemplate,
		"create":   createTemplate,
		"update":   updateTemplate,
		"delete":   deleteTemplate,
		"list":     listTemplate,
		"paginate": TemplatePaginationSharedListPaginated, // Using template manager
	}

	// Generate each requested CRUD operation
	first := true
	for _, function := range functions {
		templateStr, exists := operationTemplates[function]
		if !exists {
			return "", fmt.Errorf("unknown function type: %s", function)
		}

		if !first {
			code.WriteString("\n\n")
		}
		first = false

		var result string
		var err error

		// Check if this is a template manager template (starts with "templates/")
		if strings.HasPrefix(templateStr, "templates/") {
			// Use template manager
			result, err = cg.templateMgr.ExecuteTemplate(templateStr, data)
			if err != nil {
				return "", fmt.Errorf("failed to execute template for %s: %w", function, err)
			}
		} else {
			// Use old inline template parsing
			tmpl, parseErr := template.New("crud").Parse(templateStr)
			if parseErr != nil {
				return "", fmt.Errorf("failed to parse template for %s: %w", function, parseErr)
			}

			var resultBuilder strings.Builder
			if err := tmpl.Execute(&resultBuilder, data); err != nil {
				return "", fmt.Errorf("failed to execute template for %s: %w", function, err)
			}
			result = resultBuilder.String()
		}

		code.WriteString(result)
	}

	return code.String(), nil
}

// prepareCRUDTemplateData prepares the data structure for CRUD templates
func (cg *CodeGenerator) prepareCRUDTemplateData(table Table) (map[string]interface{}, error) {
	structName := table.GoStructName()
	repositoryName := structName + "Repository"
	receiverName := strings.ToLower(structName[:1])
	idColumn := table.GetPrimaryKeyColumn()
	createParamIndex := 1
	updateParamIndex := 1

	// Build column lists
	var selectColumns []string
	var scanArgs []string
	var createFields []map[string]string
	var updateFields []map[string]string
	var insertColumns []string
	var insertPlaceholders []string
	var insertArgs []string
	var updateAssignments []string
	var updateArgs []string

	for _, col := range table.Columns {
		// Select columns and scan args (for all operations)
		selectColumns = append(selectColumns, col.Name)
		scanArgs = append(scanArgs, "&"+receiverName+"."+col.GoFieldName())

		// Skip ID column for create/update params (it's auto-generated)
		if col.Name == idColumn.Name {
			continue
		}

		// Create fields (exclude ID and columns with defaults)
		if col.DefaultValue == "" {
			createFields = append(createFields, map[string]string{
				"Name": col.GoFieldName(),
				"Type": col.GoType,
				"Tag":  col.GoStructTag(),
			})

			insertColumns = append(insertColumns, col.Name)
			insertPlaceholders = append(insertPlaceholders, fmt.Sprintf("$%d", createParamIndex))
			insertArgs = append(insertArgs, "params."+col.GoFieldName())
			createParamIndex++
		}

		// Update fields (all non-ID columns)
		updateFields = append(updateFields, map[string]string{
			"Name": col.GoFieldName(),
			"Type": col.GoType,
			"Tag":  col.GoStructTag(),
		})

		updateAssignments = append(updateAssignments, fmt.Sprintf("%s = $%d", col.Name, updateParamIndex))
		updateArgs = append(updateArgs, "params."+col.GoFieldName())
		updateParamIndex++
	}

	// ID parameter comes last in update
	updateArgs = append(updateArgs, "id")
	idParamIndex := updateParamIndex

	return map[string]interface{}{
		"StructName":         structName,
		"RepositoryName":     repositoryName,
		"ReceiverName":       receiverName,
		"TableName":          table.Name,
		"IDColumn":           idColumn.Name,
		"IDParamIndex":       idParamIndex,
		"SelectColumns":      strings.Join(selectColumns, ", "),
		"ScanArgs":           strings.Join(scanArgs, ", "),
		"CreateFields":       createFields,
		"UpdateFields":       updateFields,
		"InsertColumns":      strings.Join(insertColumns, ", "),
		"InsertPlaceholders": strings.Join(insertPlaceholders, ", "),
		"InsertArgs":         strings.Join(insertArgs, ", "),
		"UpdateAssignments":  strings.Join(updateAssignments, ", "),
		"UpdateArgs":         strings.Join(updateArgs, ", "),
	}, nil
}

// combineImports combines and deduplicates import lists
func (cg *CodeGenerator) combineImports(lists ...[]string) []string {
	seen := make(map[string]bool)
	var result []string

	for _, list := range lists {
		for _, imp := range list {
			if !seen[imp] {
				seen[imp] = true
				result = append(result, imp)
			}
		}
	}

	return result
}

// GenerateSharedPaginationTypes generates the shared pagination types file
func (cg *CodeGenerator) GenerateSharedPaginationTypes() error {
	// Prepare template data
	data := struct {
		PackageName string
	}{
		PackageName: cg.config.PackageName,
	}

	// Execute template using template manager
	result, err := cg.templateMgr.ExecuteTemplate(TemplatePaginationSharedTypes, data)
	if err != nil {
		return fmt.Errorf("failed to execute pagination template: %w", err)
	}

	// Write to file
	filename := cg.config.GetOutputPath("pagination.go")
	if err := cg.writeCodeToFile(filename, result); err != nil {
		return fmt.Errorf("failed to write pagination file: %w", err)
	}

	return nil
}

// writeCodeToFile writes generated code to a file with proper formatting
func (cg *CodeGenerator) writeCodeToFile(filename, code string) error {
	// Format the code
	formatted, err := format.Source([]byte(code))
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	// Write to file
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", filename, err)
	}

	if cg.config.Verbose {
		fmt.Printf("Generated: %s\n", filename)
	}

	return nil
}

// generatePaginatedListWithSharedTypes generates just the paginated list method using shared types
func (cg *CodeGenerator) generatePaginatedListWithSharedTypes(table Table) (string, error) {
	// Prepare template data
	data, err := cg.prepareCRUDTemplateData(table)
	if err != nil {
		return "", fmt.Errorf("failed to prepare template data: %w", err)
	}

	// Use the shared pagination template via template manager
	result, err := cg.templateMgr.ExecuteTemplate(TemplatePaginationSharedListPaginated, data)
	if err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return result, nil
}

// generateRepositoryWithSharedTypes generates a complete repository using shared pagination types
func (cg *CodeGenerator) generateRepositoryWithSharedTypes(table Table) (string, error) {
	// Get required imports
	imports := cg.typeMapper.GetRequiredImports(table.Columns)

	// Prepare template data
	data, err := cg.prepareCRUDTemplateData(table)
	if err != nil {
		return "", fmt.Errorf("failed to prepare template data: %w", err)
	}

	// Add extra imports and package info for the template
	data["ExtraImports"] = imports
	data["PackageName"] = cg.config.PackageName

	// Execute template
	tmpl, err := template.New("repository").Parse(repositoryFileTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse repository template: %w", err)
	}

	var result strings.Builder
	if err := tmpl.Execute(&result, data); err != nil {
		return "", fmt.Errorf("failed to execute repository template: %w", err)
	}

	return result.String(), nil
}

func (cg *CodeGenerator) GenerateQueries(queries []Query) error {
	if len(queries) == 0 {
		return nil
	}

	// Group queries by source file
	queryGroups := cg.groupQueriesByFile(queries)

	// Generate code for each file group
	for sourceFile, fileQueries := range queryGroups {
		if err := cg.generateQueryFile(sourceFile, fileQueries); err != nil {
			return fmt.Errorf("failed to generate queries for file %s: %w", sourceFile, err)
		}
	}

	return nil
}

// groupQueriesByFile groups queries by their source file
func (cg *CodeGenerator) groupQueriesByFile(queries []Query) map[string][]Query {
	groups := make(map[string][]Query)
	for _, query := range queries {
		groups[query.SourceFile] = append(groups[query.SourceFile], query)
	}
	return groups
}

// generateQueryFile generates a complete Go file for a group of queries from the same source file
func (cg *CodeGenerator) generateQueryFile(sourceFile string, queries []Query) error {
	if len(queries) == 0 {
		return nil
	}

	// Map column types for all queries
	for i := range queries {
		if err := cg.typeMapper.MapQueryColumns(&queries[i]); err != nil {
			return fmt.Errorf("failed to map column types for query %s: %w", queries[i].Name, err)
		}
	}

	// Generate the code
	code, err := cg.generateQueryCode(sourceFile, queries)
	if err != nil {
		return fmt.Errorf("failed to generate query code: %w", err)
	}

	// Get output filename from first query (they all have the same source file)
	filename := cg.config.GetOutputPath(queries[0].GoFileName())

	// Write to file
	if err := cg.writeCodeToFile(filename, code); err != nil {
		return fmt.Errorf("failed to write query code to file: %w", err)
	}

	return nil
}

// generateQueryCode generates the complete Go code for a group of queries from the same source file
func (cg *CodeGenerator) generateQueryCode(sourceFile string, queries []Query) (string, error) {
	// Get required imports from all queries
	allImports := cg.getQueryImports(queries)

	// Add standard imports
	standardImports := []string{
		"context",
		"github.com/jackc/pgx/v5/pgxpool",
		"github.com/google/uuid",
	}

	// Check if any queries are paginated and add pagination imports
	hasPaginatedQueries := false
	for _, query := range queries {
		if query.Type == QueryTypePaginated {
			hasPaginatedQueries = true
			break
		}
	}

	if hasPaginatedQueries {
		standardImports = append(standardImports, "fmt", "encoding/base64")
	}

	// Combine and deduplicate imports
	allImports = cg.combineImports(standardImports, allImports)

	var code strings.Builder

	// Header
	code.WriteString("// Code generated by dbutil-gen. DO NOT EDIT.\n")
	code.WriteString(fmt.Sprintf("// Source: %s\n\n", sourceFile))

	// Package declaration
	code.WriteString(fmt.Sprintf("package %s\n\n", cg.config.PackageName))

	// Imports
	if len(allImports) > 0 {
		code.WriteString("import (\n")
		for _, imp := range allImports {
			code.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
		}
		code.WriteString(")\n\n")
	}

	// Generate result structs for queries that need them
	structsGenerated := make(map[string]bool)
	for _, query := range queries {
		if cg.needsResultStruct(query) {
			structName := cg.getQueryResultStructName(query)
			if !structsGenerated[structName] {
				structCode, err := cg.generateQueryResultStruct(query)
				if err != nil {
					return "", fmt.Errorf("failed to generate result struct for query %s: %w", query.Name, err)
				}
				code.WriteString(structCode)
				code.WriteString("\n\n")
				structsGenerated[structName] = true
			}
		}
	}

	// Generate pagination types and utilities if needed
	if hasPaginatedQueries {
		paginationCode, err := cg.generateInlinePaginationTypes()
		if err != nil {
			return "", fmt.Errorf("failed to generate pagination types: %w", err)
		}
		code.WriteString(paginationCode)
		code.WriteString("\n\n")
	}

	// Generate repository struct and constructor
	repoCode, err := cg.generateQueryRepository(sourceFile, queries)
	if err != nil {
		return "", fmt.Errorf("failed to generate query repository: %w", err)
	}
	code.WriteString(repoCode)
	code.WriteString("\n\n")

	// Generate functions for each query
	for i, query := range queries {
		if i > 0 {
			code.WriteString("\n\n")
		}

		functionCode, err := cg.generateQueryFunction(query)
		if err != nil {
			return "", fmt.Errorf("failed to generate function for query %s: %w", query.Name, err)
		}
		code.WriteString(functionCode)
	}

	return code.String(), nil
}

// generateInlinePaginationTypes generates pagination types and utilities inline for query files
func (cg *CodeGenerator) generateInlinePaginationTypes() (string, error) {
	tmpl := `// PaginationParams holds parameters for cursor-based pagination
type PaginationParams struct {
	// Cursor is the base64-encoded UUID to start pagination from
	// If empty, starts from the beginning
	Cursor string ` + "`json:\"cursor,omitempty\"`" + `

	// Limit is the maximum number of items to return
	// Must be between 1 and 100, defaults to 20
	Limit int32 ` + "`json:\"limit,omitempty\"`" + `
}

// PaginationResult holds the result of a paginated query
type PaginationResult[T any] struct {
	// Items is the list of items returned
	Items []T ` + "`json:\"items\"`" + `

	// HasMore indicates if there are more items available
	HasMore bool ` + "`json:\"has_more\"`" + `

	// NextCursor is the cursor for the next page
	// Only set if HasMore is true
	NextCursor string ` + "`json:\"next_cursor,omitempty\"`" + `
}

// encodeCursor encodes a UUID as a base64 cursor
func encodeCursor(id uuid.UUID) string {
	return base64.URLEncoding.EncodeToString(id[:])
}

// decodeCursor decodes a base64 cursor to a UUID
func decodeCursor(cursor string) (uuid.UUID, error) {
	if cursor == "" {
		return uuid.UUID{}, nil
	}

	data, err := base64.URLEncoding.DecodeString(cursor)
	if err != nil {
		return uuid.UUID{}, fmt.Errorf("invalid cursor format: %w", err)
	}

	if len(data) != 16 {
		return uuid.UUID{}, fmt.Errorf("invalid cursor length: expected 16 bytes, got %d", len(data))
	}

	var id uuid.UUID
	copy(id[:], data)
	return id, nil
}

// validatePaginationParams validates pagination parameters
func validatePaginationParams(params PaginationParams) error {
	if params.Limit <= 0 {
		return fmt.Errorf("limit must be positive, got %d", params.Limit)
	}
	if params.Limit > 100 {
		return fmt.Errorf("limit too large: maximum 100, got %d", params.Limit)
	}
	return nil
}`

	return tmpl, nil
}
