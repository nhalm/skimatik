// Code generated by dbutil-gen. DO NOT EDIT.
// Repository for {{.TableName}} table

package {{.PackageName}}

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
{{range .ExtraImports}}	"{{.}}"
{{end}})

// {{.StructName}} represents a row from the {{.TableName}} table
type {{.StructName}} struct {
{{range .Fields}}	{{.Name}} {{.Type}} `{{.Tag}}`
{{end}}}

// GetID returns the ID of the {{.StructName}} for pagination
func ({{.ReceiverName}} {{.StructName}}) GetID() uuid.UUID {
	return {{.ReceiverName}}.{{.IDField}}
}

// Create{{.StructName}}Params holds parameters for creating a {{.StructName}}
type Create{{.StructName}}Params struct {
{{range .CreateFields}}	{{.Name}} {{.Type}} `{{.Tag}}`
{{end}}}

// Update{{.StructName}}Params holds parameters for updating a {{.StructName}}
type Update{{.StructName}}Params struct {
{{range .UpdateFields}}	{{.Name}} {{.Type}} `{{.Tag}}`
{{end}}}

// {{.RepositoryName}} provides database operations for {{.TableName}}
type {{.RepositoryName}} struct {
	conn *pgxpool.Pool
}

// New{{.RepositoryName}} creates a new {{.RepositoryName}}
func New{{.RepositoryName}}(conn *pgxpool.Pool) *{{.RepositoryName}} {
	return &{{.RepositoryName}}{
		conn: conn,
	}
}

// GetByID retrieves a {{.StructName}} by its ID
func (r *{{.RepositoryName}}) GetByID(ctx context.Context, id uuid.UUID) (*{{.StructName}}, error) {
	query := `
		SELECT {{.SelectColumns}}
		FROM {{.TableName}}
		WHERE {{.IDColumn}} = $1
	`
	
	var {{.ReceiverName}} {{.StructName}}
	err := r.conn.QueryRow(ctx, query, id).Scan({{.ScanArgs}})
	if err != nil {
		return nil, err
	}
	
	return &{{.ReceiverName}}, nil
}

// Create creates a new {{.StructName}}
func (r *{{.RepositoryName}}) Create(ctx context.Context, params Create{{.StructName}}Params) (*{{.StructName}}, error) {
	query := `
		INSERT INTO {{.TableName}} ({{.InsertColumns}})
		VALUES ({{.InsertPlaceholders}})
		RETURNING {{.SelectColumns}}
	`
	
	var {{.ReceiverName}} {{.StructName}}
	err := r.conn.QueryRow(ctx, query, {{.InsertArgs}}).Scan({{.ScanArgs}})
	if err != nil {
		return nil, err
	}
	
	return &{{.ReceiverName}}, nil
}

// Update updates a {{.StructName}} by ID
func (r *{{.RepositoryName}}) Update(ctx context.Context, id uuid.UUID, params Update{{.StructName}}Params) (*{{.StructName}}, error) {
	query := `
		UPDATE {{.TableName}}
		SET {{.UpdateAssignments}}
		WHERE {{.IDColumn}} = ${{.IDParamIndex}}
		RETURNING {{.SelectColumns}}
	`
	
	var {{.ReceiverName}} {{.StructName}}
	err := r.conn.QueryRow(ctx, query, {{.UpdateArgs}}).Scan({{.ScanArgs}})
	if err != nil {
		return nil, err
	}
	
	return &{{.ReceiverName}}, nil
}

// Delete deletes a {{.StructName}} by ID
func (r *{{.RepositoryName}}) Delete(ctx context.Context, id uuid.UUID) error {
	query := `
		DELETE FROM {{.TableName}}
		WHERE {{.IDColumn}} = $1
	`
	
	_, err := r.conn.Exec(ctx, query, id)
	return err
}

// List retrieves all {{.StructName}}s
func (r *{{.RepositoryName}}) List(ctx context.Context) ([]{{.StructName}}, error) {
	query := `
		SELECT {{.SelectColumns}}
		FROM {{.TableName}}
		ORDER BY {{.IDColumn}} ASC
	`
	
	rows, err := r.conn.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	
	var results []{{.StructName}}
	for rows.Next() {
		var {{.ReceiverName}} {{.StructName}}
		err := rows.Scan({{.ScanArgs}})
		if err != nil {
			return nil, err
		}
		results = append(results, {{.ReceiverName}})
	}
	
	return results, rows.Err()
}

// ListPaginated retrieves {{.StructName}}s with cursor-based pagination
func (r *{{.RepositoryName}}) ListPaginated(ctx context.Context, params PaginationParams) (*PaginationResult[{{.StructName}}], error) {
	// Validate parameters
	if err := ValidatePaginationParams(params); err != nil {
		return nil, err
	}

	// Set default limit
	limit := params.Limit
	if limit <= 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100
	}

	// Parse cursor if provided
	var cursor *uuid.UUID
	if params.Cursor != "" {
		cursorUUID, err := DecodeCursor(params.Cursor)
		if err != nil {
			return nil, fmt.Errorf("invalid cursor format: %w", err)
		}
		cursor = &cursorUUID
	}

	// Execute query with limit + 1 to check if there are more items
	query := `
		SELECT {{.SelectColumns}}
		FROM {{.TableName}}
		WHERE ($1::uuid IS NULL OR {{.IDColumn}} > $1)
		ORDER BY {{.IDColumn}} ASC
		LIMIT $2
	`
	
	rows, err := r.conn.Query(ctx, query, cursor, int32(limit+1))
	if err != nil {
		return nil, fmt.Errorf("pagination query failed: %w", err)
	}
	defer rows.Close()
	
	var items []{{.StructName}}
	for rows.Next() {
		var {{.ReceiverName}} {{.StructName}}
		err := rows.Scan({{.ScanArgs}})
		if err != nil {
			return nil, err
		}
		items = append(items, {{.ReceiverName}})
	}
	
	if err := rows.Err(); err != nil {
		return nil, err
	}

	// Check if there are more items
	hasMore := len(items) > limit
	if hasMore {
		items = items[:limit] // Remove the extra item
	}

	// Generate next cursor if there are more items
	var nextCursor string
	if hasMore && len(items) > 0 {
		lastItem := items[len(items)-1]
		nextCursor = EncodeCursor(lastItem.GetID())
	}

	return &PaginationResult[{{.StructName}}]{
		Items:      items,
		HasMore:    hasMore,
		NextCursor: nextCursor,
	}, nil
} 