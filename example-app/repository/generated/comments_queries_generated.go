// Code generated by skimatik. DO NOT EDIT.
// Source: database/queries/comments.sql

package generated

import (
	"context"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nhalm/pgxkit"
)

// GetPostCommentsResult represents the result of the GetPostComments query
type GetPostCommentsResult struct {
	Id          pgtype.UUID        `json:"id" db:"id"`
	Content     pgtype.Text        `json:"content" db:"content"`
	CreatedAt   pgtype.Timestamptz `json:"created_at" db:"created_at"`
	IsApproved  pgtype.Bool        `json:"is_approved" db:"is_approved"`
	AuthorName  pgtype.Text        `json:"author_name" db:"author_name"`
	AuthorEmail pgtype.Text        `json:"author_email" db:"author_email"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetPostCommentsResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetUnapprovedCommentsResult represents the result of the GetUnapprovedComments query
type GetUnapprovedCommentsResult struct {
	Id         pgtype.UUID        `json:"id" db:"id"`
	Content    pgtype.Text        `json:"content" db:"content"`
	CreatedAt  pgtype.Timestamptz `json:"created_at" db:"created_at"`
	PostId     pgtype.UUID        `json:"post_id" db:"post_id"`
	AuthorName pgtype.Text        `json:"author_name" db:"author_name"`
	PostTitle  pgtype.Text        `json:"post_title" db:"post_title"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetUnapprovedCommentsResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetUserCommentCountResult represents the result of the GetUserCommentCount query
type GetUserCommentCountResult struct {
	CommentCount pgtype.Int8 `json:"comment_count" db:"comment_count"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetUserCommentCountResult) GetID() uuid.UUID {
	// No UUID field found, return zero UUID
	return uuid.UUID{}
}

// CommentsQueries provides database operations for queries in database/queries/comments.sql
type CommentsQueries struct {
	db *pgxkit.DB
}

// NewCommentsQueries creates a new CommentsQueries
func NewCommentsQueries(db *pgxkit.DB) *CommentsQueries {
	return &CommentsQueries{
		db: db,
	}
}

// GetPostComments executes the GetPostComments query and returns multiple results
func (r *CommentsQueries) GetPostComments(ctx context.Context, param1 string) ([]GetPostCommentsResult, error) {
	query := `SELECT c.id, c.content, c.created_at, c.is_approved,
       u.name as author_name, u.email as author_email
FROM comments c
JOIN users u ON c.author_id = u.id
WHERE c.post_id = $1 AND c.is_approved = true
ORDER BY c.created_at ASC;`

	rows, err := ExecuteQuery(ctx, r.db, "GetPostComments", "GetPostCommentsResult", query, param1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []GetPostCommentsResult
	for rows.Next() {
		var result GetPostCommentsResult
		err := rows.Scan(&result.Id, &result.Content, &result.CreatedAt, &result.IsApproved, &result.AuthorName, &result.AuthorEmail)
		if err != nil {
			return nil, HandleDatabaseError("scan", "GetPostCommentsResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("GetPostCommentsResult", rows)
}

// GetUnapprovedComments executes the GetUnapprovedComments query and returns multiple results
func (r *CommentsQueries) GetUnapprovedComments(ctx context.Context) ([]GetUnapprovedCommentsResult, error) {
	query := `SELECT c.id, c.content, c.created_at, c.post_id,
       u.name as author_name,
       p.title as post_title
FROM comments c
JOIN users u ON c.author_id = u.id
JOIN posts p ON c.post_id = p.id
WHERE c.is_approved = false
ORDER BY c.created_at DESC;`

	rows, err := ExecuteQuery(ctx, r.db, "GetUnapprovedComments", "GetUnapprovedCommentsResult", query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []GetUnapprovedCommentsResult
	for rows.Next() {
		var result GetUnapprovedCommentsResult
		err := rows.Scan(&result.Id, &result.Content, &result.CreatedAt, &result.PostId, &result.AuthorName, &result.PostTitle)
		if err != nil {
			return nil, HandleDatabaseError("scan", "GetUnapprovedCommentsResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("GetUnapprovedCommentsResult", rows)
}

// ApproveComment executes the ApproveComment query
func (r *CommentsQueries) ApproveComment(ctx context.Context, param1 uuid.UUID) error {
	query := `UPDATE comments 
SET is_approved = true 
WHERE id = $1;`

	return ExecuteNonQuery(ctx, r.db, "ApproveComment", "ApproveComment", query, param1)
}

// GetUserCommentCount executes the GetUserCommentCount query and returns a single result
func (r *CommentsQueries) GetUserCommentCount(ctx context.Context, param1 string) (*GetUserCommentCountResult, error) {
	query := `SELECT COUNT(*) as comment_count
FROM comments 
WHERE author_id = $1 AND is_approved = true;`

	var result GetUserCommentCountResult
	row := ExecuteQueryRow(ctx, r.db, "GetUserCommentCount", "GetUserCommentCountResult", query, param1)
	err := row.Scan(&result.CommentCount)
	if err := HandleQueryRowError("GetUserCommentCount", "GetUserCommentCountResult", err); err != nil {
		return nil, err
	}

	return &result, nil
}
