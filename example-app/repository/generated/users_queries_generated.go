// Code generated by skimatik. DO NOT EDIT.
// Source: database/queries/users.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nhalm/pgxkit"
)

// GetUserByEmailResult represents the result of the GetUserByEmail query
type GetUserByEmailResult struct {
	Id        pgtype.UUID        `json:"id" db:"id"`
	Name      pgtype.Text        `json:"name" db:"name"`
	Email     pgtype.Text        `json:"email" db:"email"`
	Bio       pgtype.Text        `json:"bio" db:"bio"`
	IsActive  pgtype.Bool        `json:"is_active" db:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at" db:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at" db:"updated_at"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetUserByEmailResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetActiveUsersResult represents the result of the GetActiveUsers query
type GetActiveUsersResult struct {
	Id        pgtype.UUID        `json:"id" db:"id"`
	Name      pgtype.Text        `json:"name" db:"name"`
	Email     pgtype.Text        `json:"email" db:"email"`
	Bio       pgtype.Text        `json:"bio" db:"bio"`
	IsActive  pgtype.Bool        `json:"is_active" db:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at" db:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at" db:"updated_at"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetActiveUsersResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetUserStatsResult represents the result of the GetUserStats query
type GetUserStatsResult struct {
	PostCount    pgtype.Int8 `json:"post_count" db:"post_count"`
	CommentCount pgtype.Int8 `json:"comment_count" db:"comment_count"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetUserStatsResult) GetID() uuid.UUID {
	// No UUID field found, return zero UUID
	return uuid.UUID{}
}

// SearchUsersResult represents the result of the SearchUsers query
type SearchUsersResult struct {
	Id        pgtype.UUID        `json:"id" db:"id"`
	Name      pgtype.Text        `json:"name" db:"name"`
	Email     pgtype.Text        `json:"email" db:"email"`
	Bio       pgtype.Text        `json:"bio" db:"bio"`
	IsActive  pgtype.Bool        `json:"is_active" db:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at" db:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at" db:"updated_at"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r SearchUsersResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// UsersQueries provides database operations for queries in database/queries/users.sql
type UsersQueries struct {
	db *pgxkit.DB
}

// NewUsersQueries creates a new UsersQueries
func NewUsersQueries(db *pgxkit.DB) *UsersQueries {
	return &UsersQueries{
		db: db,
	}
}

// GetUserByEmail executes the GetUserByEmail query and returns a single result
func (r *UsersQueries) GetUserByEmail(ctx context.Context, param1 string) (*GetUserByEmailResult, error) {
	query := `SELECT id, name, email, bio, is_active, created_at, updated_at
FROM users 
WHERE email = $1 AND is_active = true;`

	var result GetUserByEmailResult
	row := ExecuteQueryRow(ctx, r.db, "GetUserByEmail", "GetUserByEmailResult", query, param1)
	err := row.Scan(&result.Id, &result.Name, &result.Email, &result.Bio, &result.IsActive, &result.CreatedAt, &result.UpdatedAt)
	if err := HandleQueryRowError("GetUserByEmail", "GetUserByEmailResult", err); err != nil {
		return nil, err
	}

	return &result, nil
}

// GetActiveUsers executes the GetActiveUsers query and returns multiple results
func (r *UsersQueries) GetActiveUsers(ctx context.Context, param1 string) ([]GetActiveUsersResult, error) {
	query := `SELECT id, name, email, bio, is_active, created_at, updated_at
FROM users 
WHERE is_active = true 
ORDER BY created_at DESC 
LIMIT $1;`

	rows, err := ExecuteQuery(ctx, r.db, "GetActiveUsers", "GetActiveUsersResult", query, param1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []GetActiveUsersResult
	for rows.Next() {
		var result GetActiveUsersResult
		err := rows.Scan(&result.Id, &result.Name, &result.Email, &result.Bio, &result.IsActive, &result.CreatedAt, &result.UpdatedAt)
		if err != nil {
			return nil, HandleDatabaseError("scan", "GetActiveUsersResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("GetActiveUsersResult", rows)
}

// GetUserStats executes the GetUserStats query and returns a single result
func (r *UsersQueries) GetUserStats(ctx context.Context, param1 string) (*GetUserStatsResult, error) {
	query := `SELECT 
    COUNT(DISTINCT p.id) as post_count,
    COUNT(DISTINCT c.id) as comment_count
FROM users u
LEFT JOIN posts p ON u.id = p.author_id AND p.is_published = true
LEFT JOIN comments c ON u.id = c.author_id AND c.is_approved = true
WHERE u.id = $1
GROUP BY u.id;`

	var result GetUserStatsResult
	row := ExecuteQueryRow(ctx, r.db, "GetUserStats", "GetUserStatsResult", query, param1)
	err := row.Scan(&result.PostCount, &result.CommentCount)
	if err := HandleQueryRowError("GetUserStats", "GetUserStatsResult", err); err != nil {
		return nil, err
	}

	return &result, nil
}

// DeactivateUser executes the DeactivateUser query
func (r *UsersQueries) DeactivateUser(ctx context.Context, param1 uuid.UUID) error {
	query := `UPDATE users SET is_active = false WHERE id = $1;`

	return ExecuteNonQuery(ctx, r.db, "DeactivateUser", "DeactivateUser", query, param1)
}

// SearchUsers executes the SearchUsers query and returns multiple results
func (r *UsersQueries) SearchUsers(ctx context.Context, param1 string, param2 string) ([]SearchUsersResult, error) {
	query := `SELECT id, name, email, bio, is_active, created_at, updated_at
FROM users 
WHERE is_active = true 
AND (name ILIKE $1 OR email ILIKE $1)
ORDER BY created_at DESC 
LIMIT $2;`

	rows, err := ExecuteQuery(ctx, r.db, "SearchUsers", "SearchUsersResult", query, param1, param2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []SearchUsersResult
	for rows.Next() {
		var result SearchUsersResult
		err := rows.Scan(&result.Id, &result.Name, &result.Email, &result.Bio, &result.IsActive, &result.CreatedAt, &result.UpdatedAt)
		if err != nil {
			return nil, HandleDatabaseError("scan", "SearchUsersResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("SearchUsersResult", rows)
}
