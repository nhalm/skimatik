// Code generated by skimatik. DO NOT EDIT.
// Source: database/queries/posts.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nhalm/pgxkit"
)

// GetPublishedPostsResult represents the result of the GetPublishedPosts query
type GetPublishedPostsResult struct {
	Id          pgtype.UUID        `json:"id" db:"id"`
	Title       pgtype.Text        `json:"title" db:"title"`
	Content     pgtype.Text        `json:"content" db:"content"`
	AuthorId    pgtype.UUID        `json:"author_id" db:"author_id"`
	PublishedAt pgtype.Timestamptz `json:"published_at" db:"published_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at" db:"created_at"`
	AuthorName  pgtype.Text        `json:"author_name" db:"author_name"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetPublishedPostsResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetPostWithAuthorResult represents the result of the GetPostWithAuthor query
type GetPostWithAuthorResult struct {
	Id          pgtype.UUID        `json:"id" db:"id"`
	Title       pgtype.Text        `json:"title" db:"title"`
	Content     pgtype.Text        `json:"content" db:"content"`
	AuthorId    pgtype.UUID        `json:"author_id" db:"author_id"`
	IsPublished pgtype.Bool        `json:"is_published" db:"is_published"`
	PublishedAt pgtype.Timestamptz `json:"published_at" db:"published_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at" db:"created_at"`
	AuthorName  pgtype.Text        `json:"author_name" db:"author_name"`
	AuthorEmail pgtype.Text        `json:"author_email" db:"author_email"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetPostWithAuthorResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetUserPostsResult represents the result of the GetUserPosts query
type GetUserPostsResult struct {
	Id          pgtype.UUID        `json:"id" db:"id"`
	Title       pgtype.Text        `json:"title" db:"title"`
	Content     pgtype.Text        `json:"content" db:"content"`
	AuthorId    pgtype.UUID        `json:"author_id" db:"author_id"`
	IsPublished pgtype.Bool        `json:"is_published" db:"is_published"`
	PublishedAt pgtype.Timestamptz `json:"published_at" db:"published_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at" db:"created_at"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetUserPostsResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// GetPostsWithCommentCountResult represents the result of the GetPostsWithCommentCount query
type GetPostsWithCommentCountResult struct {
	Id           pgtype.UUID        `json:"id" db:"id"`
	Title        pgtype.Text        `json:"title" db:"title"`
	AuthorId     pgtype.UUID        `json:"author_id" db:"author_id"`
	PublishedAt  pgtype.Timestamptz `json:"published_at" db:"published_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at" db:"created_at"`
	AuthorName   pgtype.Text        `json:"author_name" db:"author_name"`
	CommentCount pgtype.Int8        `json:"comment_count" db:"comment_count"`
}

// GetID returns the ID field for pagination (assumes first UUID field is the ID)
func (r GetPostsWithCommentCountResult) GetID() uuid.UUID {
	return uuid.UUID(r.Id.Bytes)
}

// PostsQueries provides database operations for queries in database/queries/posts.sql
type PostsQueries struct {
	db *pgxkit.DB
}

// NewPostsQueries creates a new PostsQueries
func NewPostsQueries(db *pgxkit.DB) *PostsQueries {
	return &PostsQueries{
		db: db,
	}
}

// GetPublishedPosts executes the GetPublishedPosts query and returns multiple results
func (r *PostsQueries) GetPublishedPosts(ctx context.Context, param1 string) ([]GetPublishedPostsResult, error) {
	query := `SELECT p.id, p.title, p.content, p.author_id, p.published_at, p.created_at,
       u.name as author_name
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.is_published = true
ORDER BY p.published_at DESC
LIMIT $1;`

	rows, err := ExecuteQuery(ctx, r.db, "GetPublishedPosts", "GetPublishedPostsResult", query, param1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []GetPublishedPostsResult
	for rows.Next() {
		var result GetPublishedPostsResult
		err := rows.Scan(&result.Id, &result.Title, &result.Content, &result.AuthorId, &result.PublishedAt, &result.CreatedAt, &result.AuthorName)
		if err != nil {
			return nil, HandleDatabaseError("scan", "GetPublishedPostsResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("GetPublishedPostsResult", rows)
}

// GetPostWithAuthor executes the GetPostWithAuthor query and returns a single result
func (r *PostsQueries) GetPostWithAuthor(ctx context.Context, param1 string) (*GetPostWithAuthorResult, error) {
	query := `SELECT p.id, p.title, p.content, p.author_id, p.is_published, p.published_at, p.created_at,
       u.name as author_name, u.email as author_email
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.id = $1;`

	var result GetPostWithAuthorResult
	row := ExecuteQueryRow(ctx, r.db, "GetPostWithAuthor", "GetPostWithAuthorResult", query, param1)
	err := row.Scan(&result.Id, &result.Title, &result.Content, &result.AuthorId, &result.IsPublished, &result.PublishedAt, &result.CreatedAt, &result.AuthorName, &result.AuthorEmail)
	if err := HandleQueryRowError("GetPostWithAuthor", "GetPostWithAuthorResult", err); err != nil {
		return nil, err
	}

	return &result, nil
}

// GetUserPosts executes the GetUserPosts query and returns multiple results
func (r *PostsQueries) GetUserPosts(ctx context.Context, param1 string) ([]GetUserPostsResult, error) {
	query := `SELECT id, title, content, author_id, is_published, published_at, created_at
FROM posts
WHERE author_id = $1
ORDER BY created_at DESC;`

	rows, err := ExecuteQuery(ctx, r.db, "GetUserPosts", "GetUserPostsResult", query, param1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []GetUserPostsResult
	for rows.Next() {
		var result GetUserPostsResult
		err := rows.Scan(&result.Id, &result.Title, &result.Content, &result.AuthorId, &result.IsPublished, &result.PublishedAt, &result.CreatedAt)
		if err != nil {
			return nil, HandleDatabaseError("scan", "GetUserPostsResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("GetUserPostsResult", rows)
}

// PublishPost executes the PublishPost query
func (r *PostsQueries) PublishPost(ctx context.Context, param1 uuid.UUID) error {
	query := `UPDATE posts 
SET is_published = true, published_at = NOW()
WHERE id = $1 AND is_published = false;`

	return ExecuteNonQuery(ctx, r.db, "PublishPost", "PublishPost", query, param1)
}

// GetPostsWithCommentCount executes the GetPostsWithCommentCount query and returns multiple results
func (r *PostsQueries) GetPostsWithCommentCount(ctx context.Context, param1 string) ([]GetPostsWithCommentCountResult, error) {
	query := `SELECT p.id, p.title, p.author_id, p.published_at, p.created_at,
       u.name as author_name,
       COUNT(c.id) as comment_count
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN comments c ON p.id = c.post_id AND c.is_approved = true
WHERE p.is_published = true
GROUP BY p.id, p.title, p.author_id, p.published_at, p.created_at, u.name
ORDER BY p.published_at DESC
LIMIT $1;`

	rows, err := ExecuteQuery(ctx, r.db, "GetPostsWithCommentCount", "GetPostsWithCommentCountResult", query, param1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []GetPostsWithCommentCountResult
	for rows.Next() {
		var result GetPostsWithCommentCountResult
		err := rows.Scan(&result.Id, &result.Title, &result.AuthorId, &result.PublishedAt, &result.CreatedAt, &result.AuthorName, &result.CommentCount)
		if err != nil {
			return nil, HandleDatabaseError("scan", "GetPostsWithCommentCountResult", err)
		}
		results = append(results, result)
	}

	return results, HandleRowsResult("GetPostsWithCommentCountResult", rows)
}
