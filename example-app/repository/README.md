# Repository Layer Architecture

This demonstrates the recommended pattern for using skimatik in a multi-layer application.

## 🏗️ Architecture Overview

```
Service Layer (business logic)
    ↓
Custom Repository (domain-specific operations)  ← YOU WRITE THIS
    ↓  
Generated Queries (type-safe database operations)  ← SKIMATIK GENERATES
    ↓
Database (PostgreSQL)
```

## 📁 Directory Structure

```
repository/
├── README.md              # This file
├── post_repository.go     # Custom repository (user-written)
└── generated/             # Generated by skimatik (DO NOT EDIT)
    ├── posts_queries.go   # Generated query methods
    ├── users_queries.go   # Generated query methods  
    └── types.go           # Generated types
```

## 🔧 Custom Repository Pattern

### PostRepository Example

The `PostRepository` demonstrates how to properly extend generated functionality:

```go
type PostRepository struct {
    // Embed generated queries for basic CRUD operations
    *generated.PostQueries
}

func NewPostRepository(queries *generated.PostQueries) *PostRepository {
    return &PostRepository{
        PostQueries: queries,
    }
}
```

### What You Get

**✅ Generated Methods (automatic):**
- `GetPublishedPosts()` - Type-safe query from SQL
- `GetPostWithAuthor()` - Complex joins made simple
- `GetUserPosts()` - Parameterized queries
- `PublishPost()` - Safe mutations

**✅ Custom Methods (you add):**
- `GetFeaturedPosts()` - Business logic on top of generated queries
- `GetPostsByTag()` - Custom filtering and composition
- `GetPostStatistics()` - Aggregate multiple queries
- `CreatePostWithValidation()` - Add validation before database calls

## 🎯 Key Benefits

### 1. **Embedded Queries**
```go
// Automatically get all generated methods
posts, err := repo.GetPublishedPosts(ctx, limit)
```

### 2. **Custom Business Logic**
```go
// Add your own methods that use generated queries
func (r *PostRepository) GetFeaturedPosts(ctx context.Context, limit int) ([]generated.GetPublishedPostsRow, error) {
    // Use generated query as foundation
    posts, err := r.PostQueries.GetPublishedPosts(ctx, int32(limit*2))
    if err != nil {
        return nil, err
    }
    
    // Add custom filtering/business logic
    return filterFeatured(posts, limit), nil
}
```

### 3. **Composition & Aggregation**
```go
// Combine multiple generated queries
func (r *PostRepository) GetPostStatistics(ctx context.Context) (*PostStats, error) {
    publishedCount, err := r.GetPublishedPostCount(ctx)
    draftCount, err := r.GetDraftPostCount(ctx)
    // Combine results into custom business object
    return &PostStats{...}, nil
}
```

### 4. **Validation & Business Rules**
```go
// Wrap generated mutations with validation
func (r *PostRepository) CreatePostWithValidation(ctx context.Context, title, content string, authorID uuid.UUID) (*generated.Post, error) {
    // Custom validation
    if len(title) < 5 {
        return nil, fmt.Errorf("title too short")
    }
    
    // Use generated method for actual database work
    return r.PostQueries.CreatePost(ctx, generated.CreatePostParams{
        Title:    title,
        Content:  content,
        AuthorID: authorID,
    })
}
```

## 🚀 Usage in Service Layer

```go
// Service uses custom repository, not generated queries directly
type postService struct {
    postRepo *repository.PostRepository  // Custom repository
}

func (s *postService) GetFeaturedPosts(ctx context.Context, limit int) ([]PostSummary, error) {
    // Service calls custom repository method
    rows, err := s.postRepo.GetFeaturedPosts(ctx, limit)
    if err != nil {
        return nil, err
    }
    
    // Convert to service-layer types
    return convertToSummaries(rows), nil
}
```

## 🔄 Code Generation Workflow

1. **Write SQL queries** in `database/queries/`
2. **Run skimatik** to generate `repository/generated/`
3. **Create custom repositories** that embed generated queries
4. **Services use custom repositories**, not generated code directly

## 🎉 Why This Pattern Works

- ✅ **Generated code stays pure** - no manual editing
- ✅ **Custom logic is isolated** - in your repository layer
- ✅ **Easy to test** - mock the custom repository interface
- ✅ **Type safety** - all the way through the stack
- ✅ **Regeneration safe** - your custom code is never overwritten
- ✅ **Clean separation** - generated vs. business logic

This is the **recommended pattern** for production applications using skimatik! 