# Example Blog Application

This is a complete example application demonstrating skimatik's recommended multi-layer architecture. It implements a simple blog with users, posts, and comments.

## üèóÔ∏è Architecture

This example demonstrates a clean multi-layer architecture with proper separation of concerns.

## üöÄ Quick Start

### Quick Start

**Three simple steps:**
```bash
make setup     # Start database and apply schema
make generate  # Generate Go code with skimatik  
make run       # Start the API server
```

**Available commands:**
```bash
make help      # Show all commands
make clean     # Clean up everything
```

Or test manually:
```bash
# Get active users
curl "http://localhost:8080/api/users"

# Get published posts
curl "http://localhost:8080/api/posts"

# Search users
curl "http://localhost:8080/api/users/search?q=alice"

# Get user statistics
curl "http://localhost:8080/api/users/{user-id}/stats"
```

## üìö Layer Details

### Generated Layer (`repository/generated/`)
- **Query-based functions** - Generated from your SQL files with annotations
- **Generated by skimatik** - Don't modify these files manually  
- **Custom queries** - Exactly the SQL you wrote, with Go type safety

### Query Layer (`database/queries/`)
- **SQL files** - Your handwritten SQL with sqlc-style annotations
- **Type annotations** - `:one`, `:many`, `:exec`, `:paginated`
- **Custom logic** - Complex joins, aggregations, business queries

### Service Layer (`service/`)
- **Business logic** - Validation, workflows, orchestration
- **Cross-cutting concerns** - Transaction management, error handling
- **Domain operations** - Complex operations spanning multiple repositories

### API Layer (`api/`)
- **HTTP concerns** - Request/response handling, routing
- **Authentication** - JWT validation, user context
- **Serialization** - JSON marshaling, validation

## üéØ Key Patterns Demonstrated

### 1. Interface-Driven Design
Services depend on repository interfaces, not implementations:
```go
type PostService interface {
    CreatePost(ctx context.Context, req CreatePostRequest) (*PostResponse, error)
    GetPost(ctx context.Context, id uuid.UUID) (*PostResponse, error)
}

type postService struct {
    postRepo repository.PostRepository  // Interface, not struct
    userRepo repository.UserRepository
}
```

### 2. Query-Based Generation
Write SQL, get type-safe Go functions:
```sql
-- name: GetPublishedPosts :many
SELECT p.id, p.title, u.name as author_name
FROM posts p JOIN users u ON p.author_id = u.id  
WHERE p.is_published = true
ORDER BY p.published_at DESC LIMIT $1;
```

skimatik generates:
```go
func (q *PostsQueries) GetPublishedPosts(ctx context.Context, limit int32) ([]GetPublishedPostsRow, error)
```

### 3. Domain Model Separation
Business models can differ from database models:
```go
// Database model (generated)
type Posts struct {
    ID       uuid.UUID
    Title    string
    Content  string
    AuthorID uuid.UUID
}

// Domain model (business layer)
type Post struct {
    ID          uuid.UUID
    Title       string
    Content     string
    AuthorName  string    // Enriched with author info
    CommentCount int      // Calculated field
}
```

### 4. Error Handling
Consistent error handling across all layers:
```go
func (s *postService) CreatePost(ctx context.Context, req CreatePostRequest) (*PostResponse, error) {
    if err := s.validatePostRequest(req); err != nil {
        return nil, fmt.Errorf("validation failed: %w", err)
    }
    
    post, err := s.postRepo.CreatePost(ctx, req.Title, req.Content, req.AuthorID)
    if err != nil {
        return nil, fmt.Errorf("failed to create post: %w", err)
    }
    
    return s.toPostResponse(post), nil
}
```

## üß™ Testing

The architecture makes testing easy:

### Unit Tests (Service Layer)
```go
func TestPostService_CreatePost(t *testing.T) {
    mockPostRepo := &mocks.PostRepository{}
    mockUserRepo := &mocks.UserRepository{}
    
    service := NewPostService(mockPostRepo, mockUserRepo)
    
    // Test business logic without database
}
```

### Integration Tests (Repository Layer)
```go
func TestPostRepository_Integration(t *testing.T) {
    testDB := setupTestDatabase(t)
    repo := NewPostRepository(testDB)
    
    // Test against real database
}
```

## üîÑ Regeneration Workflow

When your database schema changes:

1. **Update schema**: Modify `database/schema.sql`
2. **Regenerate code**: Run skimatik to update `repository/generated/`
3. **Update repositories**: Modify domain repositories if needed
4. **Update services**: Adjust business logic for schema changes
5. **Update API**: Modify handlers for new endpoints

Your custom code in `repository/`, `service/`, and `api/` remains intact!

## üìñ Related Documentation

- **[Multi-Layer Architecture Guide](../docs/embedding-patterns.md)** - Detailed architecture patterns
- **[Quick Start Guide](../docs/quick-start.md)** - Basic skimatik usage
- **[Configuration Reference](../docs/configuration-reference.md)** - All configuration options 